package gocode

import (
	"fmt"
	"go/format"
	"go/types"
	"path/filepath"
	"runtime"
	"strings"

	"github.com/mmcloughlin/ec3/internal/print"
)

type Generator struct {
	print.Buffer
}

func NewGenerator() Generator {
	return Generator{
		Buffer: print.NewBuffer(),
	}
}

func (g *Generator) Package(name string) {
	g.Linef("package %s", name)
}

func (g *Generator) Import(pkgs ...string) {
	g.NL()
	if len(pkgs) == 1 {
		g.Linef("import %q", pkgs[0])
		return
	}

	g.Linef("import (")
	for _, pkg := range pkgs {
		g.Linef("\t%q", pkg)
	}
	g.Linef(")")
}

// Comment writes comment lines prefixed with "// ".
func (g *Generator) Comment(lines ...string) {
	for _, line := range lines {
		g.Linef("// %s", line)
	}
}

func (g *Generator) Commentf(format string, args ...interface{}) {
	g.Comment(fmt.Sprintf(format, args...))
}

func (g *Generator) CodeGenerationWarning(by string) {
	g.Commentf("Code generated by %s. DO NOT EDIT.", by)
	g.NL() // newline to ensure it does not get attached to package documentation
}

func (g *Generator) CodeGenerationWarningSelf() {
	_, self, _, _ := runtime.Caller(1)
	g.CodeGenerationWarning(filepath.Base(self))
}

func (g *Generator) EnterBlock() {
	g.Linef("{")
	g.Indent()
}

func (g *Generator) LeaveBlock() {
	g.Dedent()
	g.Linef("}")
}

func (g *Generator) Function(name string, s *types.Signature) {
	g.Printf("func %s", name)
	types.WriteSignature(g.Buf, s, nil)
	g.EnterBlock()
}

func (g *Generator) ByteArrayValue(b []byte) {
	// Short arrays on one line.
	if len(b) < 8 {
		array := fmt.Sprintf("%#v", b)
		g.Linef(strings.TrimPrefix(array, "[]byte"))
		return
	}

	// Longer arrays encoded as a multi-line block.
	g.EnterBlock()
	for i, x := range b {
		g.Printf("%#02x, ", x)
		if (i+1)%8 == 0 {
			g.NL()
		}
	}
	g.NL()
	g.LeaveBlock()
}

func (g *Generator) Formatted() ([]byte, error) {
	b, err := g.Result()
	if err != nil {
		return nil, err
	}
	return format.Source(b)
}
