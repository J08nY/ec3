// Code generated by ec3. DO NOT EDIT.

package p256

// Size of a field element in bytes.
const Size = 32

// Elt is a field element.
type Elt [32]uint8

// Sqr computes z = x^2 (mod p).
func Sqr(z *Elt, x *Elt) {
	Mul(z, x, x)
}

// Inv computes z = 1/x (mod p).
func Inv(z *Elt, x *Elt) {
	// Inversion computation is derived from the addition chain:
	//
	// _10     = 2*1
	// _11     = 1 + _10
	// _1100   = _11 << 2
	// _1111   = _11 + _1100
	// _111100 = _1111 << 2
	// _111111 = _11 + _111100
	// x12     = _111111 << 6 + _111111
	// x24     = x12 << 12 + x12
	// x30     = x24 << 6 + _111111
	// x32     = x30 << 2 + _11
	// i232    = ((x32 << 32 + 1) << 128 + x32) << 32
	// return    ((x32 + i232) << 30 + x30) << 2
	//
	// Operations: 255 squares 11 multiplies

	// Allocate 3 temporaries.
	var t [3]Elt

	// Step 1: z = x^0x2.
	Sqr(z, x)

	// Step 2: &t[0] = x^0x3.
	Mul(&t[0], x, z)

	// Step 4: z = x^0xc.
	Sqr(z, &t[0])
	for s := 1; s < 2; s++ {
		Sqr(z, z)
	}

	// Step 5: z = x^0xf.
	Mul(z, &t[0], z)

	// Step 7: z = x^0x3c.
	for s := 0; s < 2; s++ {
		Sqr(z, z)
	}

	// Step 8: z = x^0x3f.
	Mul(z, &t[0], z)

	// Step 14: &t[1] = x^0xfc0.
	Sqr(&t[1], z)
	for s := 1; s < 6; s++ {
		Sqr(&t[1], &t[1])
	}

	// Step 15: &t[1] = x^0xfff.
	Mul(&t[1], z, &t[1])

	// Step 27: &t[2] = x^0xfff000.
	Sqr(&t[2], &t[1])
	for s := 1; s < 12; s++ {
		Sqr(&t[2], &t[2])
	}

	// Step 28: &t[1] = x^0xffffff.
	Mul(&t[1], &t[1], &t[2])

	// Step 34: &t[1] = x^0x3fffffc0.
	for s := 0; s < 6; s++ {
		Sqr(&t[1], &t[1])
	}

	// Step 35: z = x^0x3fffffff.
	Mul(z, z, &t[1])

	// Step 37: &t[1] = x^0xfffffffc.
	Sqr(&t[1], z)
	for s := 1; s < 2; s++ {
		Sqr(&t[1], &t[1])
	}

	// Step 38: &t[0] = x^0xffffffff.
	Mul(&t[0], &t[0], &t[1])

	// Step 70: &t[1] = x^0xffffffff00000000.
	Sqr(&t[1], &t[0])
	for s := 1; s < 32; s++ {
		Sqr(&t[1], &t[1])
	}

	// Step 71: &t[1] = x^0xffffffff00000001.
	Mul(&t[1], x, &t[1])

	// Step 199: &t[1] = x^0xffffffff0000000100000000000000000000000000000000.
	for s := 0; s < 128; s++ {
		Sqr(&t[1], &t[1])
	}

	// Step 200: &t[1] = x^0xffffffff00000001000000000000000000000000ffffffff.
	Mul(&t[1], &t[0], &t[1])

	// Step 232: &t[1] = x^0xffffffff00000001000000000000000000000000ffffffff00000000.
	for s := 0; s < 32; s++ {
		Sqr(&t[1], &t[1])
	}

	// Step 233: &t[0] = x^0xffffffff00000001000000000000000000000000ffffffffffffffff.
	Mul(&t[0], &t[0], &t[1])

	// Step 263: &t[0] = x^0x3fffffffc00000004000000000000000000000003fffffffffffffffc0000000.
	for s := 0; s < 30; s++ {
		Sqr(&t[0], &t[0])
	}

	// Step 264: z = x^0x3fffffffc00000004000000000000000000000003fffffffffffffffffffffff.
	Mul(z, z, &t[0])

	// Step 266: z = x^0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc.
	for s := 0; s < 2; s++ {
		Sqr(z, z)
	}
}
