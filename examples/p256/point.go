// Code generated by ec3. DO NOT EDIT.

package p256

import "math/big"

var (
	bi, _ = new(big.Int).SetString("41058363725152142129326129780047268409114441015993725554835256314039467401291", 10)
	b     = new(Elt).SetInt(bi)
)

type Affine struct {
	X Elt
	Y Elt
}

func NewAffine(X, Y *big.Int) *Affine {
	p := new(Affine)
	p.X.SetInt(X)
	p.Y.SetInt(Y)
	return p
}

func (p *Affine) Set(q *Affine) {
	*p = *q
}

func (p *Affine) Coordinates() (X, Y *big.Int) {
	X = p.X.Int()
	Y = p.Y.Int()
	return
}

func (a *Affine) Jacobian() (p *Jacobian) {
	p = new(Jacobian)
	p.X = a.X
	p.Y = a.Y
	p.Z.SetInt64(1)
	return
}

func (a *Affine) Projective() (p *Projective) {
	p = new(Projective)
	p.X = a.X
	p.Y = a.Y
	p.Z.SetInt64(1)
	return
}

type Jacobian struct {
	X Elt
	Y Elt
	Z Elt
}

func NewJacobian(X, Y, Z *big.Int) *Jacobian {
	p := new(Jacobian)
	p.X.SetInt(X)
	p.Y.SetInt(Y)
	p.Z.SetInt(Z)
	return p
}

func (p *Jacobian) Set(q *Jacobian) {
	*p = *q
}

func (p *Jacobian) Coordinates() (X, Y, Z *big.Int) {
	X = p.X.Int()
	Y = p.Y.Int()
	Z = p.Z.Int()
	return
}

func (p *Jacobian) Affine() (a *Affine) {
	a = new(Affine)
	var (
		A  Elt
		AA Elt
		t0 Elt
	)

	Inv(&A, &p.Z)
	Sqr(&AA, &A)
	Mul(&a.X, &p.X, &AA)
	Mul(&t0, &AA, &A)
	Mul(&a.Y, &p.Y, &t0)
	return
}

func (p *Jacobian) Projective() (q *Projective) {
	q = new(Projective)
	Mul(&q.X, &p.X, &p.Z)
	q.Y = p.Y
	Sqr(&q.Z, &p.Z)
	Mul(&q.Z, &q.Z, &p.Z)
	return
}

func (p *Jacobian) CMov(q *Jacobian, c uint) {
	CMov(&p.X, &q.X, c)
	CMov(&p.Y, &q.Y, c)
	CMov(&p.Z, &q.Z, c)
}

func (p *Jacobian) CNeg(c uint) {
	var t Elt
	Neg(&t, &p.Y)
	CMov(&p.Y, &t, c)
}

func (p *Jacobian) Add(q *Jacobian, r *Jacobian) {
	add(&q.X, &r.X, &p.X, &q.Y, &r.Y, &p.Y, &q.Z, &r.Z, &p.Z)
}

func (p *Jacobian) Double(q *Jacobian) {
	double(&q.X, &p.X, &q.Y, &p.Y, &q.Z, &p.Z)
}

type Projective struct {
	X Elt
	Y Elt
	Z Elt
}

func NewProjective(X, Y, Z *big.Int) *Projective {
	p := new(Projective)
	p.X.SetInt(X)
	p.Y.SetInt(Y)
	p.Z.SetInt(Z)
	return p
}

func (p *Projective) Set(q *Projective) {
	*p = *q
}

func (p *Projective) Coordinates() (X, Y, Z *big.Int) {
	X = p.X.Int()
	Y = p.Y.Int()
	Z = p.Z.Int()
	return
}

func (p *Projective) Affine() (a *Affine) {
	a = new(Affine)
	var A Elt
	Inv(&A, &p.Z)
	Mul(&a.X, &A, &p.X)
	Mul(&a.Y, &A, &p.Y)
	return
}

func (p *Projective) CNeg(c uint) {
	var t Elt
	Neg(&t, &p.Y)
	CMov(&p.Y, &t, c)
}

func (p *Projective) CompleteAdd(q *Projective, r *Projective) {
	completeadd(&q.X, &r.X, &p.X, &q.Y, &r.Y, &p.Y, &q.Z, &r.Z, &p.Z, b)
}
